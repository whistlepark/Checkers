My first intuiton when designing this game was to determine all possible moves, and determine what's the max amount of opponent pieces can be captured and/or if it's possible to get a piece to the back row in order to convert it to a King. This would require me to decide how many opponent pieces would I need to be able to capture to make it more worth it than attaining a King. This method would require me to also decide how to make a move if it's impossible to attain a new King and it's impossible to capture an opponent piece. This would possibly require me to analyze either possible future moves (as in the moves of my next turn and my next-next turn) or my opponent's possible next move in order to play more defensively. I think this could be best implemented with a vector holding all possible moves, or perhaps a dictionary with the move as the key and the value being how many opponent pieces are capture to determine which move captures the most opponent pieces. This seemed incredibly complicated and like it most likely wouldn't be very fast.  

After some research, I found one strategy that could be used is minmaxing. A very simple minmaxing method I could use would be to setup a recursive function that makes a move, and calls itself again to determine how the game could potentially end. Because checkers is a zero sum game, the moves would be symmetric for the opposing player. Each possible branch of moves would be assigned a value based on how ideal the ultimate outcome is. We could define the values by the ability to win, or if it's impossible to win, how many more turns we are able to take, how many opponent pieces we are able to capture in the process, or a combination of both. 

I think this could be best implemented with some kind of tree. Each possible move for the turn is a branch off the node, and each possible move after that move is documented in the nodes branching from the "level 1" nodes (the nodes branching off directly from the roots, a.k.a. the possible moves for this turn and not any future turns). Then, as these branches are filled, the values can be calculated for which "level 1" node is most beneficial. 
